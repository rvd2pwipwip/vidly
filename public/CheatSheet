1.in terminal, run create-react-app vidly
2.cd in vidly to install bootstrap and font-awesome:
npm i bootstrap@4.1.1 font-awesome@4.7.0
3.import css files for bootstrap and font-awesome in index.js:
import "bootstrap/dist/css/bootstrap.css";
import "font-awesome/css/font-awesome.css";
4.in the project folder, start the project:
npm start
5.replace the default react app with basic bootstrap template.
go to getbootstrap.com > examples > framework > starter template
look for <main role="main" class="container"> in page source
6.in App.js, delete everything in the return of the render() and replace with:
<main className="container">
  <h1>Hello World</h1>
</main>
7.get the Starter Code.zip and copy the Services folder in the project src folder
8.create components folder in src folder and create App.jsx component (will replace App.js)
9.create Movies component and test render with console log:
import React, { Component } from "react";
import { getMovies } from "../services/fakeMovieService";

class Movies extends Component {
  state = { movies: getMovies() };
  render() {
    return <h2>Movies Component</h2>;
  }
}

export default Movies;
10.import Movies in App.js and insert a <Movie/> component in the .main div:
import React, { Component } from "react";
import Movies from "./Movies";

class App extends Component {
  render() {
    return (
      <main className="container">
        <Movies />
      </main>
    );
  }
}

export default App;
11.create table in render method by typing table.table>thead>tr>th*4 to output (emmet):
render() {
    return (
      <table className="table">
        <thead>
          <tr>
            <th></th>
            <th></th>
            <th></th>
            <th></th>
          </tr>
        </thead>
      </table>
    );
  }
}
12.enter the 4 <th/> names:
<th>Title</th>
<th>Genre</th>
<th>Stock</th>
<th>Rate</th>
13.inside the <table/>, below the <thead>, create the body by typing tbody>tr>td*4
14.render the <td/> tags dynamically by applying a map function on the state.movies:
<tbody>
  {this.state.movies.map(m => (
    <tr key={m._id}>
      <td>{m.title}</td>
      <td>{m.genre.name}</td>
      <td>{m.numberInStock}</td>
      <td>{m.dailyRentalRate}</td>
    </tr>
  ))}
</tbody>
15.add a fifth <th/> with no text to the <thead/> and a fifth <td/> to the <tbody/> to add a delete button:
<td>
  <button className="btn btn-danger btn-sm"> //bootstrap styles for small red button
    Delete
  </button>
</td>
16.handle click event in <button/>:
<button
  className="btn btn-danger btn-sm"
  onClick={this.handleDelete}
>
  Delete
</button>
17.create new handleDelete => function just above render() in <Movies/>:
handleDelete = () => {
  console.log("deleting");
};
18.add the movie to be deleted as a parameter of handleDelete() and change the onClick call
of the <button/> to an => function so it can pass the movie id to handleDelete():
handleDelete = movie => {
  console.table(movie);
};

<button
  className="btn btn-danger btn-sm"
  onClick={() => {
    this.handleDelete(m);
  }}
>
  Delete
</button>
19.update the state by applying a filter to the current movies:
handleDelete = movie => {
  const movies = this.state.movies.filter(m => m._id !== movie._id);
  this.setState({ movies });
};
20.create a common folder inside the components folder
21.create a Like.jsx file inside the common folder
22.copy font awesome markup for empty heart icon and paste it into render() of <Like/>
don't forget to chege class to className -fontawesome was npm installed in the packages
(https://fontawesome.com/v4.7.0/icon/heart-o):
import React, { Component } from "react";

// input: liked boolean
// output: onClick

class Like extends Component {
  state = {};
  render() {
    return <i className="fa fa-heart-o" aria-hidden="true" />;
  }
}

export default Like;
22.in Movies.jsx, add a new column <th/> with a <Like/> inside before the delete <th>:
<table className="table">
  <thead>
    <tr>
      <th>Title</th>
      <th>Genre</th>
      <th>Stock</th>
      <th>Rate</th>
      <th />
      <th />
    </tr>
  </thead>
  <tbody>
    {this.state.movies.map(m => (
      <tr key={m._id}>
        <td>{m.title}</td>
        <td>{m.genre.name}</td>
        <td>{m.numberInStock}</td>
        <td>{m.dailyRentalRate}</td>
        <td>
          <Like />
        </td>
        <td>
          <button
            className="btn btn-danger btn-sm"
            onClick={() => {
              this.handleDelete(m);
            }}
          >
            Delete
          </button>
        </td>
      </tr>
    ))}
  </tbody>
</table>
23.create a liked prop inside the <Like/> component of the table and set it to true:
<Like liked={true} />
24.modify the <Like/> render() to change the className if liked props 
is true (className="fa fa-heart") or false (className="fa fa-heart-o"):
class Like extends Component {
  state = {};
  render() {
    let classes = "fa fa-heart";
    return (
      <i
        className={this.props.liked ? classes : `${classes}-o`}
        aria-hidden="true"
      />
    );
  }
}
25.in Movies.jsx, change the hard coded liked props to be dynamically set to each movie liked value:
<Like liked={m.liked} />
26.in fakeMovieService, add a liked property to the first movie and set it to true then save to confirm
27.set the onClick prop of <i/> in Like.jsx to props.handleLiked and add inline style for hand pointer:
return (
  <i
    className={this.props.liked ? classes : `${classes}-o`}
    aria-hidden="true"
    onClick={this.props.handleLiked}
    style={{ cursor: "pointer" }}
  />
);
28.in Movies.jsx, create the handleLiked prop inside the <Like/> component, set it to this.handleLiked()
and create the function handleLiked() to display a console.log('Liked'):
handleLiked = () => {
  console.log("Liked");
}
...
<Like liked={m.liked} handleLiked={this.handleLiked} />
29.change the handleLiked prop to an => function to pass the clicke movie to this.handleLiked:
<Like liked={m.liked} handleLiked={() => this.handleLiked(m)} />
30.change the handleLiked() to log which movie was clicked:
handleLiked = movie => {
  console.log("Liked", movie);
};
31.change the handleLiked() to copy the state, find the liked movie, toggle its liked property and updtae the state:
handleLiked = movie => {
  // 1. copy state
  const movies = [...this.state.movies];
  // 2. find movie index and update its liked property
  const index = movies.indexOf(movie);
  movies[index].liked = !movies[index].liked;
  // 3. update state
  this.setState({ movies });
};
32.Like.jsx can be changed to an sfc:
import React from "react";

const Like = props => {
  let classes = "fa fa-heart";
  return (
    <i
      className={props.liked ? classes : `${classes}-o`}
      aria-hidden="true"
      onClick={props.handleLiked}
      style={{ cursor: "pointer" }}
    />
  );
};

export default Like;
33.create a new Pagination.jsx file inside common, then imr and sfc, 
name the component Pagination and pass the props as an argument:
import React from "react";

const Pagination = props => {
  return ();
};

export default Pagination;
34.go to bootstrap documentation and find the markup for a pagination component
(https://getbootstrap.com/docs/4.1/components/pagination/) to paste it in the return():
import React from "react";

const Pagination = props => {
  return (
    <nav aria-label="Page navigation example">
      <ul className="pagination">
        <li className="page-item">
          <a className="page-link" href="#">
            1
          </a>
        </li>
      </ul>
    </nav>
  );
};

export default Pagination;
35.in Movies.jsx, import then add the new <Pagination/> component below the table:
import Pagination from "./common/Pagination";
...
<Pagination/>
36.add pagination props to the component (# of items and page size):
<Pagination itemsCount={this.state.movies.length} pageSize={this.state.pageSize} />
37.initialize pageSize property in the state:
state = { movies: getMovies(), pageSize: 4 };
38.add handlePageChange prop to Pagination:
<Pagination
  itemsCount={this.state.movies.length}
  pageSize={this.state.pageSize}
  handlePageChange={this.handlePageChange}
/>
39.create the handlePageChange function of Movies to confirm with a log:
handlePageChange = page => {
  console.log(page);
};
40.in Pagination.jsx, create the itemsCount and PageSize const to determine the page count:
const { itemsCount, pageSize } = props;
const pagesCount = Math.ceil(itemsCount / pageSize);
41.console cd in vidly and npm install lodash to use it to generate an array of the number of pages:
npm i lodash@4.17.10
42.import lodash in Pagination.jsx:
import _ from "lodash";
43.use lodash to create a pages array with keys [1, 2, 3]:
const pages = _.range(1, pagesCount + 1);
44.map the pages array to create a <li/> for each page:
<ul className="pagination">
  {pages.map(p => (
    <li key={p} className="page-item">
      <a className="page-link" href="#">
        {p}
      </a>
    </li>
  ))}
</ul>
45.in Pagination.jsx raise the click event of the <a/> element:
<a className="page-link" onClick={() => props.handlePageChange(p)}>{p}</a>
46.keep using already created object destructuring for props.handlePageChange:
const { itemsCount, pageSize, handlePageChange } = props;
...
<a className="page-link" onClick={() => handlePageChange(p)}>
47.to highlight the current page on the <Pagination/> component, create a currentPage
porperty in Movies.sate and pass it down to <Pagination/> then to <a/> via props:
state = { movies: getMovies(), pageSize: 4, currentPage: 1 };
...
<Pagination
  itemsCount={this.state.movies.length}
  pageSize={this.state.pageSize}
  handlePageChange={this.handlePageChange}
  currentPage={this.state.currentPage}
/>
... in Pagination.jsx:
const { itemsCount, pageSize, handlePageChange, currentPage } = props;
48.refactor Movies.jsx state properties with object destructuring:
render() {
  const { length: count } = this.state.movies;
  const { pageSize, currentPage } = this.state;
...
<p>Showing {count} movies in the database.</p>
...
<Pagination
  itemsCount={count}
  pageSize={pageSize}
  currentPage={currentPage}
  handlePageChange={this.handlePageChange}
/>
49.change code of handlePageChange() to update the state of Movies:
handlePageChange = page => {
  this.setState({ currentPage: page });
};
50.use ternary expression to append 'active' to the class of <li/> if it is the current page:
<li
  key={p}
  className={currentPage === p ? "page-item active" : "page-item"}
>
  <a className="page-link" onClick={() => handlePageChange(p)}>
    {p}
  </a>
</li>
51.create a new utils folder inside src and add a new paginate.js file inside.
52.import lodash in the paginate.js file:
import _ from "lodash";
53.export the paginate function that will be written in this file:
export function paginate()
54.add the parameters that will be neede to paginate:
export function paginate(items, pageNumber, pageSize)
55.calculate the starting index of items on current page:
const startIndex = (pageNumber - 1) * pageSize;
56.chain lodash methods to return new array of page items:
return _(items)
  .slice(startIndex)
  .take(pageSize)
  .value();
57.import the paginate function in Movies.jsx:
import { paginate } from "../utils/paginate";
58.inside render(), call the paginate() and pass the state movies, currentPage and PageSize:
const { pageSize, currentPage, movies } = this.state;
...
const movies = paginate(movies, currentPage, pageSize);
59.instead of mapping this.state.movies, we need to map over the local (paged) movies:
<tbody>
  {movies.map(m => (
60.remove duplicate declaration "movies" error by renaming movies in destructured declaration:
const { pageSize, currentPage, movies: allMovies } = this.state;
...
const movies = paginate(allMovies, currentPage, pageSize);
61.console cd in vidly and npm install prop-types in the project to allow type checking:
npm i prop-types@15.6.2
62.import prop-types in the Pagination component:
import PropTypes from 'prop-types'
63.add new propTypes property to Pagination below its definition:
...
};

Pagination.propTypes = {
  itemsCount: PropTypes.number.isRequired,
  pageSize: PropTypes.number.isRequired,
  handlePageChange: PropTypes.func.isRequired,
  currentPage: PropTypes.number.isRequired
};

export default Pagination;
64.create a new FilterGroup.jsx file inside the common folder
65.in FilterGroup.jsx, imr and sfc to write code for a stateless functional component named FilterGroup:
import React from "react";

const FilterGroup = props => {
  return (  );
};

export default FilterGroup;
66.in Movies.jsx, import the new FilterGroup component:
import FilterGroup from "./common/FilterGroup";
67.replace the React.Fragment <></> with a div with a className of row that has two col divs inside
div.row>div.col-3+div.col:
<div className="row">
  <div className="col-3"></div>
  <div className="col"></div>
</div>
68.put a <FilterGroup/> inside the first col and put all the rest in the second col:
<div className="row">
  <div className="col-3">
    <FilterGroup/>
  </div>
  <div className="col">
    <p>Showing {count} movies in the database.</p>
    <table className="table">
    ...
69.import the genres list with getGenres() from fakeGenreService.js into Movies.jsx:
import { getGenres } from "../services/fakeGenreService";
70.add the genres property in the state and assign it an empty array:
state = {
  movies: getMovies(),
  genres: [],
  pageSize: 4,
  currentPage: 1,
  currentFilter: null
};
71.add a componentDidMount() below the state:
componentDidMount(){
  
}
72.assign an empty array to the movies of state:
state = {
  movies: [],
  genres: [],
  pageSize: 4,
  currentPage: 1,
  currentFilter: null
};
73.set the state movies and genres in the componentDidMount():
componentDidMount() {
  this.setState({ movies: getMovies(), genres: getGenres() });
}
74.pass the genres of state as an items prop of FilterGroup:
<FilterGroup items={this.state.genres} />
75.add an item selection event handler to FilterGroup:
<FilterGroup
  items={this.state.genres}
  handleItemSelect={this.handleGenreSelect}
/>
76.add a handleGenreSelect() to Movies that will console log the passed genre:
handleGenreSelect = genre => {
  console.log(genre);
}
77.in FilterGroup.js, destructure the passed items props and map each of them to a <li/> elements
of the list-group ul (https://getbootstrap.com/docs/4.1/components/list-group/):
const FilterGroup = props => {
  const { items } = props;

  return (
    <ul className="list-group">
      {items.map(i => (
        <li key={i._id} className={"list-group-item"}>
          {i.name}
        </li>
      ))}
    </ul>
  );
};
78.to decouple the FilterGroup component from the data of Movies, add 2 new props to 
<FilterGroup/> in Movies.jsx:
<FilterGroup
  items={this.state.genres}
  textProperty="name"
  valueProperty="_id"
  handleItemSelect={this.handleGenreSelect}
/>
79.grab the 2 new props inside FilterGroup.jsx:
const { items, textProperty, valueProperty } = props;
80.replace . notation with [] notation to get the .name and the ._id of each <li/>:
<ul className="list-group">
  {items.map(i => (
    <li key={i[valueProperty]} className={"list-group-item"}>
      {i[textProperty]}
    </li>
  ))}
</ul>
81.in FilterGroup.jsx, use defaultProps to simplify the <FilterGroup/> in Movies.jsx 
(no need to pass the defaultProps):
FilterGroup.defaultProps = {
  valueProperty: "_id",
  textProperty: "name"
};
82.in FilterGroup.jsx, deconstruct the handleItemSelect fucntion passed via props:
const { items, textProperty, valueProperty, handleItemSelect } = props;
83.add an onClick event to the <li/> elements of FilterGroup to call handleItemSelect and pass
the clicked item (and add the style={{ cursor: "pointer" }} attribute):
<li
  key={i[valueProperty]}
  className={"list-group-item"}
  onClick={() => handleItemSelect(i)}
  style={{ cursor: "pointer" }}
>
  {i[textProperty]}
</li>
84.in FilterGroup.jsx, write the handleGenreSelect to set the state to the clicked item:
handleGenreSelect = genre => {
  this.setState({ selectedGenre: genre });
};
85.in FilterGroup.jsx, extract the new prop (selectedItem):
const { items, textProperty, valueProperty, handleItemSelect, selectedItem } = props;
86.dynamically change the class of <li/> if its item is the same as the one that was clicked:
<li
  key={i[valueProperty]}
  className={
    i === selectedItem ? "list-group-item active" : "list-group-item"
  }
  onClick={() => handleItemSelect(i)}
  style={{ cursor: "pointer" }}
>
  {i[textProperty]}
</li>
87.in Movies.jsx render method, extract the selectedGenre from the state 
(along with other deconstructed state properties):
88.filter the movies before pagination with ternary operator:
const filteredMovies = selectedGenre
  ? allMovies.filter(m => m.genre._id === selectedGenre._id)
  : allMovies;
89.paginate filteredMovies instead of allMovies:
const movies = paginate(filteredMovies, currentPage, pageSize);
90.in the <Pagination/> component, assign the filteredMovies.length to itemsCount (instead of count):
<Pagination
  itemsCount={filteredMovies.length}
  pageSize={pageSize}
  currentPage={currentPage}
  handlePageChange={this.handlePageChange}
/>
91.in the <p/>, change the { count } to { filteredMovies.length } to show the proper number of
movies shown:
<p>Showing {filteredMovies.length} movies in the database.</p>
92.add All Genres in state genres array and set the state with this new array:
componentDidMount() {
  const genres = [{ _id: 0, name: "AllGenres" }, ...getGenres()];
  this.setState({ movies: getMovies(), genres });
}
93.change the filter condition so it doesn't filter if the id of selectedGenre is 0
const filteredMovies =
  selectedGenre && selectedGenre !== 0
    ? allMovies.filter(m => m.genre._id === selectedGenre._id)
    : allMovies;
94.reset the current page to page 1 whenever a genre is selected:
handleGenreSelect = genre => {
  this.setState({ selectedGenre: genre, currentPage: 1 });
};
95.refactor the table into its own sfc file:
import React from "react";
import Like from "./common/Like";

const MoviesTable = props => {
  const { movies, handleDelete, handleLiked } = props;
  return (
    <>
      <table className="table">
        <thead>
          <tr>
            <th>Title</th>
            <th>Genre</th>
            <th>Stock</th>
            <th>Rate</th>
            <th />
            <th />
          </tr>
        </thead>
        <tbody>
          {movies.map(m => (
            <tr key={m._id}>
              <td>{m.title}</td>
              <td>{m.genre.name}</td>
              <td>{m.numberInStock}</td>
              <td>{m.dailyRentalRate}</td>
              <td>
                <Like liked={m.liked} handleLiked={() => handleLiked(m)} />
              </td>
              <td>
                <button
                  className="btn btn-danger btn-sm"
                  onClick={() => {
                    handleDelete(m);
                  }}
                >
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </>
  );
};

export default MoviesTable;
96.import the MoviesTable component in Movies.jsx:
import MoviesTable from "./MoviesTable";
97.insert the <MoviesTable/> between <p/> and <Pagination/> with the needed props:
<MoviesTable
  movies={movies}
  handleDelete={this.handleDelete}
  handleLiked={this.handleLiked}
/>
98.in MoviesTable.jsx, extract a new handleSort with props destructuring:
const { movies, handleDelete, handleLiked, handleSort } = props;
99.assign the handleSort prop to the onClick of each <th/> and pass the appropriate sort criteria:
<tr>
  <th onClick={() => handleSort("title")}>Title</th>
  <th onClick={() => handleSort("genre.name")}>Genre</th>
  <th onClick={() => handleSort("numberInStock")}>Stock</th>
  <th onClick={() => handleSort("dailyRentalRate")}>Rate</th>
  <th />
  <th />
</tr>
100.in Movies.jsx, assign the handleSort as a props of <MoviesTable/>:
<MoviesTable
  movies={movies}
  handleDelete={this.handleDelete}
  handleLiked={this.handleLiked}
  handleSort={this.handleSort}
/>
101.create the handleSort() and console.log the passed argument to validate the plumbing works:
handleSort = sort => {
  console.log("sorting", sort);
};
102.modify the handleSort() to set the state by passing a sortColumn object:
handleSort = sort => {
  this.setState({ sortColumn: { sort: sort, order: "asc" } });
};
103.add a new sortColumn property to the state of Movies.jsx:
state = {
  movies: [],
  genres: [],
  pageSize: 4,
  currentPage: 1,
  sortColumn: { sort: "title", order: "asc" }
};
104.import lodash into Movies.jsx to use it to implement the ascending sort:
import _ from "lodash";
105.extract the sortColumn from the state object destructuring inside the render():
const {
  pageSize,
  currentPage,
  movies: allMovies,
  selectedGenre,
  sortColumn
} = this.state;
105.in the render method, sorting should be done between filtering and paginating:
const sorted = _.orderBy(
  filteredMovies,
  [sortColumn.sort],
  [sortColumn.order]
);
106.pass the sorted movies to paginate:
const movies = paginate(sorted, currentPage, pageSize);
107.implement the reverse sort:
handleSort = sort => {
  const sortColumn = { ...this.state.sortColumn };
  if (sortColumn.sort === sort) {
    sortColumn.order = sortColumn.order === "asc" ? "desc" : "asc";
  } else {
    sortColumn.sort = sort;
    sortColumn.order = "asc";
  }
  this.setState({ sortColumn });
};
107.to move the sorting code from Movies to MoviesTable, promote MoviesTable from sfc to cc:
import React, { Component } from "react";
import Like from "./common/Like";

class MoviesTable extends Component {
  state = {};

  render() {
    const { movies, handleDelete, handleLiked, handleSort } = this.props;
    return (
      <>
        <table className="table">
          <thead>
            <tr>
              <th onClick={() => handleSort("title")}>Title</th>
              <th onClick={() => handleSort("genre.name")}>Genre</th>
              <th onClick={() => handleSort("numberInStock")}>Stock</th>
              <th onClick={() => handleSort("dailyRentalRate")}>Rate</th>
              <th />
              <th />
            </tr>
          </thead>
          <tbody>
            {movies.map(m => (
              <tr key={m._id}>
                <td>{m.title}</td>
                <td>{m.genre.name}</td>
                <td>{m.numberInStock}</td>
                <td>{m.dailyRentalRate}</td>
                <td>
                  <Like liked={m.liked} handleLiked={() => handleLiked(m)} />
                </td>
                <td>
                  <button
                    className="btn btn-danger btn-sm"
                    onClick={() => {
                      handleDelete(m);
                    }}
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </>
    );
  }
}

export default MoviesTable;
108.copy the code from the handleSort() of Movies.jsx in a new onSort() in MoviesTable.jsx
and modify it to get the sortColumn from the props (instead of state) and return the updated
sortColumn to the handleSort() of Movies.jsx:
onSort = sort => {
  const sortColumn = { ...this.props.sortColumn };
  if (sortColumn.sort === sort) {
    sortColumn.order = sortColumn.order === "asc" ? "desc" : "asc";
  } else {
    sortColumn.sort = sort;
    sortColumn.order = "asc";
  }
  this.props.handleSort(sortColumn);
};
109.in Movies.jsx, pass the sortColumn of state and the handleSort() as props of MoviesTable:
<MoviesTable
  movies={movies}
  handleDelete={this.handleDelete}
  handleLiked={this.handleLiked}
  sortColumn={this.state.sortColumn}
  handleSort={this.handleSort}
/>
110.update the handleSort() to receive the sortColumn argument (instead of sort):
handleSort = sortColumn => {
  this.setState({ sortColumn });
};
111.create a new tableHeader.jsx cc file in the common folder:
import React, { Component } from 'react';

class TableHeader extends Component {
  state = {  }
  render() { 
    return (  );
  }
}
 
export default TableHeader;
112.copy the sorting code from MoviesTable into TableHeader:
class TableHeader extends Component {
  state = {  }

  onSort = sort => {
    const sortColumn = { ...this.props.sortColumn };
    if (sortColumn.sort === sort) {
      sortColumn.order = sortColumn.order === "asc" ? "desc" : "asc";
    } else {
      sortColumn.sort = sort;
      sortColumn.order = "asc";
    }
    this.props.handleSort(sortColumn);
  };

  render() { 
    return (  );
  }
}
113.add render code to display a <thead> with a <tr> that has a <th> for each column:
render() { 
  return ( 
    <thead>
      <tr>
        {this.props.columns.map(c => <th>{c.label}</th>)}
      </tr>
  </thead> );
} 
114.copy the first <th> onClick expression from MoviesTable in the <th> of TableHeader:
<thead>
  <tr>
    {this.props.columns.map(c => (
      <th onClick={() => this.onSort("title")}>{c.label}</th>
    ))}
  </tr>
</thead>
115.instead of "title", pass the path to the target property:
<th onClick={() => this.onSort(c.path)}>{c.label}</th>
116.import the new <TableHeader/> in MoviesTable.jsx:
import TableHeader from "./common/TableHeader";
...
117.create a new columns array in MoviesTable:
class MoviesTable extends Component {
  columns = [
    { path: "title", label: "Title" },
    { path: "genre.name", label: "Genre" },
    { path: "numberInStock", label: "Stock" },
    { path: "dailyRentalRate", label: "Rate" },
    {}, //like col, no path no label
    {} //delete col, no path no label
  ]; //will not change, no need for a state
118.replace the <thead/> by the new <TableHeader/> with the needed props:
render() {
  const {
    movies,
    handleDelete,
    handleLiked,
    handleSort,
    sortColumn
  } = this.props;
  return (
    <>
      <table className="table">
        <TableHeader
          columns={this.columns}
          sortColumn={sortColumn}
          handleSort={handleSort}
        />
        <tbody>
        ...
119.add key attributes to the like and delete columns of MoviesTable:
columns = [
  { path: "title", label: "Title" },
  { path: "genre.name", label: "Genre" },
  { path: "numberInStock", label: "Stock" },
  { path: "dailyRentalRate", label: "Rate" },
  { key: "like" }, //like col, no path no label
  { key: "delete" } //delete col, no path no label
]; //will not change, no need for a state
120.in TableHeader.jsx, add a key attribute to the <th/> assigned to either
the column path or the column key (for like and delete):
<tr>
  {this.props.columns.map(c => (
    <th key={c.path || c.key} onClick={() => this.onSort(c.path)}>
      {c.label}
    </th>
  ))}
</tr>
121.create a new TableBody.jsx cc file in the common folder:
import React, { Component } from 'react';

class TableBody extends Component {
  state = {  }
  render() { 
    return (  );
  }
}
 
export default TableBody;
122.in MoviesTable.jsx, import the new TableBody and insert it below the <TableHeader/>:
import TableBody from "./common/TableBody";
...
<TableHeader
  columns={this.columns}
  sortColumn={sortColumn}
  handleSort={handleSort}
/>
<TableBody/>
...
124.add a data attribute to <TableBody/> to pass the (decoupled) movies:
<TableBody data={movies} />
125.the <TableBody/> should return <tbody> elements:
render() {
    return (
      <tbody>
        <tr>
          <td />
        </tr>
      </tbody>
    );
  }
126.use object destructuring to extract the props data (movies) and the columns:
render() {
  const { data, columns } = this.props;
  return (
    <tbody>
      {data.map(i => (
        <tr>
          {columns.map(c => (
            <td />
          ))}
        </tr>
      ))}
    </tbody>
  );
}
127.import lodash to use the _.get() that can get nested properties (like genre.name):
<tbody>
  {data.map(i => (
    <tr>
      {columns.map(c => (
        <td>{_.get(i, c.path)}</td>
      ))}
    </tr>
  ))}
</tbody>
128.in the columns array of MoviesTable, pass the jsx markup for the like and the
delete columns as content attributes:
columns = [
  { path: "title", label: "Title" },
  { path: "genre.name", label: "Genre" },
  { path: "numberInStock", label: "Stock" },
  { path: "dailyRentalRate", label: "Rate" },
  {
    key: "like",
    content: <Like liked={m.liked} handleLiked={() => handleLiked(m)} />
  },
  {
    key: "delete",
    content: (
      <button
        className="btn btn-danger btn-sm"
        onClick={() => {
          handleDelete(m);
        }}
      >
        Delete
      </button>
    )
  }
];
129.get rid of the old <tbody/> markup in MoviesTable.jsx:
<table className="table">
  <TableHeader
    columns={this.columns}
    sortColumn={sortColumn}
    handleSort={handleSort}
  />
  <TableBody data={movies} columns={this.columns} />
</table>
130.in the columns array, change the content attribute of like and delete from react
elements to arrow functions and pass the handleLiked() and handleDelete() from this.props:
{
  key: "like",
  content: m => (
    <Like liked={m.liked} handleLiked={() => this.props.handleLiked(m)} />
  )
},
{
  key: "delete",
  content: m => (
    <button
      className="btn btn-danger btn-sm"
      onClick={() => {
        this.props.handleDelete(m);
      }}
    >
      Delete
    </button>
  )
}
131.create a new renderCell() to render <td/> with a content attribute or path:
class TableBody extends Component {
  renderCell = (i, c) => {
    if (c.content) return c.content(i);
    return _.get(i, c.path);
  };
132.call the renderCell in the <tr/>:
<tr>
  {columns.map(c => (
    <td>{this.renderCell(i, c)}</td>
  ))}
</tr>
133.in TableBody.jsx, give unique keys to the <tr/> and <td/> elements based on
the id of their data:
{data.map(i => (
  <tr key={i._id}>
    {columns.map(c => (
      <td key={i._id + (c.path || c.key)}>{this.renderCell(i, c)}</td>
    ))}
  </tr>
))}
134.simplify the <td/> code by creating a createKey():
createKey = (i, c) => {
  return i._id + (c.path || c.key);
};

render() {
  const { data, columns } = this.props;
  return (
    <tbody>
      {data.map(i => (
        <tr key={i._id}>
          {columns.map(c => (
            <td key={this.createKey(i, c)}>{this.renderCell(i, c)}</td>
          ))}
        </tr>
      ))}
    </tbody>
  );
}
135.handleDelete and handleLike are not needed in MoviesTable.jsx anymore:
render() {
  const {
    movies,
    // handleDelete,
    // handleLiked,
    handleSort,
    sortColumn
  } = this.props;
136.in the <th/> of TableHeader.jsx, add a call to renderSortIcon(c) right after the column label:
<th key={c.path || c.key} onClick={() => this.onSort(c.path)}>
  {c.label} {this.renderSortIcon(c)}
</th>
137.the renderSortIcon should render the sort icon if the column.path is the same as the sortColumn.sort
and then it should be ascending or descending, depending on the sortColumn order
renderSortIcon = column => {
  const { sortColumn } = this.props;
  if (column.path !== sortColumn.sort || !column.path) return null;
  if (sortColumn.order === "asc") return <i className="fa fa-sort-asc" />;
  return <i className="fa fa-sort-desc" />;
};
138.in index.css add a new css with a class selector of clickable that makes the cursor a pointer:
.clickable {
  cursor: pointer;
}
139.add the clickable class to the <th/> element in TableHeader.jsx:
<th
  key={c.path || c.key}
  onClick={() => this.onSort(c.path)}
  className="clickable"
>
  {c.label} {this.renderSortIcon(c)}
</th>
140.create anew Table.jsx file in the common folder
141.imr than sfc to create the frame of a functional component:
import React from "react";

const Table = props => {
  return ();
};

export default Table;
142.cut the code for the <table/> in MoviesTable.jsx and paste it in the return of
the render() of Table.jsx:
const Table = props => {
  return (
    <table className="table">
      <TableHeader
        columns={this.columns}
        sortColumn={sortColumn}
        handleSort={handleSort}
      />
      <TableBody data={movies} columns={this.columns} />
    </table>
  );
};

export default Table;
143.use object destructuring to get the needed props and modify their reference:
const Table = props => {
  const { columns, sortColumn, handleSort, data } = props;
  return (
    <table className="table">
      <TableHeader
        columns={columns}
        sortColumn={sortColumn}
        handleSort={handleSort}
      />
      <TableBody data={data} columns={columns} />
    </table>
  );
};
144.import the table components that make up the <Table/> and remove their import 
from MoviesTable.jsx where they are not needed anymore:
import TableHeader from "./TableHeader";
import TableBody from "./TableBody";
145.import the new <Table/> component in MoviesTable since it will be needed toreplace the
old <table/> markup in the render():
import React, { Component } from "react";
import Like from "./common/Like";
import Table from "./common/Table";
146.insert the <Table/> inside the render and assign it the appropriate props:
render() {
  const { movies, handleSort, sortColumn } = this.props;
  return (
    <>
      <Table
        data={movies}
        handleSort={handleSort}
        sortColumn={sortColumn}
        columns={this.columns}
      />
    </>
  );
}
147.in Movies.jsx, cut the code for the filtering and the sorting of the movies to extract this to a new method
148.paste the code in a new getPagedData() and make it return an object with the count of moviesand the movies themselves:
getPagedData = () => {
  const filteredMovies =
    selectedGenre && selectedGenre._id
      ? allMovies.filter(m => m.genre._id === selectedGenre._id)
      : allMovies;

  const sorted = _.orderBy(
    filteredMovies,
    [sortColumn.sort],
    [sortColumn.order]
  );

  const movies = paginate(sorted, currentPage, pageSize);

  return {totalCount: filteredMovies.length, data: movies}
}
149.call the getPagedData just before the return() and destructure the result:
const { totalCount, data: movies } = this.getPagedData();

return (
...
150.in the return() of Movies.jsx, replace the references to filteredMovies.length with
references to totalCount:
<p>Showing {totalCount} movies in the database.</p>
...
<Pagination
  itemsCount={totalCount}
151.use object destructuring in the getPagedData() to pass the needed data to its code:
getPagedData = () => {
  const {
    pageSize,
    currentPage,
    movies: allMovies,
    selectedGenre,
    sortColumn
  } = this.state;
152.get rid of the unnecessary const in the render():
render() {
  const { length: count } = this.state.movies;
  const { pageSize, currentPage } = this.state;
153.in Table.jsx, destructure the props argument to get rid of the destructuring line:
const Table = ({ columns, sortColumn, handleSort, data }) => {
  return (
...
154.do the same for all sfc's (FilterGroup, Like and Pagination) in the common folder:
const FilterGroup = ({
  items,
  textProperty,
  valueProperty,
  handleItemSelect,
  selectedItem
}) => {

const Like = ({ liked, handleLiked }) 

const Pagination = ({
  itemsCount,
  pageSize,
  handlePageChange,
  currentPage
}) => {
/////////////// Exercises NavBar and Routing ///////////////
155.import the react-router-dom module in the project:
npm i react-router-dom
156.import the react-router-dom BrowserRouter into index.js:
import { BrowserRouter } from "react-router-dom";
157.wrap the <App/> component inside a <BrowserRouter/> (the BrowserRouter will pass the 
browser history, location and match props to <App/> and all its children components):
ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
);
158.create new sfc files for Customers, MovieForm, NotFound and Rentals in the component folder
159.in App.jsx, import then add the <NavBar/> on top of the page:
import React, { Component } from "react";
import Movies from "./Movies";
import NavBar from "./common/NavBar";

class App extends Component {
  render() {
    return (
      <>
        <NavBar />
        <main className="container">
          <Movies />
        </main>
      </>
    );
  }
}

export default App;
160.import Route from react-router-dom:
import React, { Component } from "react";
import { Route } from "react-router-dom";
import Movies from "./Movies";
import NavBar from "./common/NavBar";
161.import the 4 new components:
import React, { Component } from "react";
import { Route } from "react-router-dom";
import Movies from "./Movies";
import NavBar from "./common/NavBar";
import Customers from "./Customers";
import MovieForm from "./MovieForm";
import NotFound from "./NotFound";
import Rentals from "./Rentals";
162.create 4 route components inside <main/> by typing emmet shortcut Route[path][component]*4
and enter the paths and components attributes for the 4 new components:
<main className="container">
  <Route path="/movies" component={Movies} />
  <Route path="/customers" component={Customers} />
  <Route path="/rentals" component={Rentals} />
  <Route path="/not-found" component={NotFound} />
</main>
163.test the app by entering the created route paths in the browser address bar
i.e. http://localhost:3001/movies
164.import Redirect from react-router-dom:
import { Route, Redirect } from "react-router-dom";
165.use Redirect to redirect from root ('/') to /movies:
<main className="container">
  <Route path="/movies" component={Movies} />
  <Route path="/customers" component={Customers} />
  <Route path="/rentals" component={Rentals} />
  <Route path="/not-found" component={NotFound} />
  <Redirect from="/" to="/movies" />
</main>
166.import Switch from rreact-router-dom:
import { Route, Redirect, Switch } from "react-router-dom";
167.wrap the routes in a <Switch/> to avoid rerouting every time with <Redirect/>:
<main className="container">
  <Switch>
    <Route path="/movies" component={Movies} />
    <Route path="/customers" component={Customers} />
    <Route path="/rentals" component={Rentals} />
    <Route path="/not-found" component={NotFound} />
    <Redirect from="/" to="/movies" />
  </Switch>
</main>
168.add Redirect for unexisting paths and add exact attribute to root redirect to avoid
a match (with all urls's starting with '/') when the path doesn't exist:
<Switch>
  <Route path="/movies" component={Movies} />
  <Route path="/customers" component={Customers} />
  <Route path="/rentals" component={Rentals} />
  <Route path="/not-found" component={NotFound} />
  <Redirect exact from="/" to="/movies" />
  <Redirect to="/not-found" />
</Switch>
169.create a new NavBar.jsx file in the common folder with a sfc that will render a <nav/> 
with Bootstrap navbar classes (https://getbootstrap.com/docs/4.1/components/navbar/):
import React from "react";
import { NavLink, Link } from "react-router-dom";

const NavBar = () => {
  return (
    <nav className="navbar navbar-expand-lg navbar-light bg-light">
      <Link className="navbar-brand" to="#">
        Vidly
      </Link>
      <button
        className="navbar-toggler"
        type="button"
        data-toggle="collapse"
        data-target="#navbarNav"
        aria-controls="navbarNav"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span className="navbar-toggler-icon" />
      </button>
      <div className="collapse navbar-collapse" id="navbarNav">
        <ul className="navbar-nav">
          <li className="nav-item active">
            <NavLink className="nav-link" to="#">
              Home <span className="sr-only">(current)</span>
            </NavLink>
          </li>
          <li className="nav-item">
            <NavLink className="nav-link" to="#">
              Features
            </NavLink>
          </li>
          <li className="nav-item">
            <NavLink className="nav-link" to="#">
              Pricing
            </NavLink>
          </li>
          <li className="nav-item">
            <NavLink className="nav-link disabled" to="#">
              Disabled
            </NavLink>
          </li>
        </ul>
      </div>
    </nav>
  );
};

export default NavBar;
170.adjust the paths (and remove the active class from Home):
<nav className="navbar navbar-expand-lg navbar-light bg-light">
  <Link className="navbar-brand" to="/">
    Vidly
  </Link>
  <button
    className="navbar-toggler"
    type="button"
    data-toggle="collapse"
    data-target="#navbarNav"
    aria-controls="navbarNav"
    aria-expanded="false"
    aria-label="Toggle navigation"
  >
    <span className="navbar-toggler-icon" />
  </button>
  <div className="collapse navbar-collapse" id="navbarNav">
    <ul className="navbar-nav">
      <li className="nav-item">
        <NavLink className="nav-link" to="/movies">
          Movies
        </NavLink>
      </li>
      <li className="nav-item">
        <NavLink className="nav-link" to="/customers">
          Customers
        </NavLink>
      </li>
      <li className="nav-item">
        <NavLink className="nav-link" to="/rentals">
          Rentals
        </NavLink>
      </li>
    </ul>
  </div>
</nav>
171.in App.jsx, import then insert the <NavBar/> just before the <main/>:
return (
  <>
    <NavBar />
    <main className="container">
      <Switch>
        <Route path="/movies" component={Movies} />
        <Route path="/customers" component={Customers} />
        <Route path="/rentals" component={Rentals} />
        <Route path="/not-found" component={NotFound} />
        <Redirect exact from="/" to="/movies" />
        <Redirect to="/not-found" />
      </Switch>
    </main>
  </>
);
172.in index.css, add bottom margin to the navbar class:
.navbar {
  margin-bottom: 1rem;
}
173.in MoviesTable.jsx, modify the first column of the table to update the browser path 
and display a <Link/> with the movie title for each movie:
{
  path: "title",
  label: "Title",
  content: m => <Link to={`/movies/${m._id}`}>{m.title}</Link>
},
174.in App.jsx, register a new route for the MovieForm path just above the <Movies/> path:
<Switch>
  <Route path="/movies/:id" component={MovieForm} />
  <Route path="/movies" component={Movies} />
  ...
175.in MovieForm.jsx, extract the movie id from the url and display it along with a 
save button that brings the users back to the movies page by pushing the '/movies'
path to the props.history:
const MovieForm = ({ match, history }) => {
  return (
    <>
      <h1>Movie Form {match.params.id}</h1>
      <button
        className="btn btn-primary"
        onClick={() => history.push("/movies")}
      >
        Save
      </button>
    </>
  );
};
/////////////////  Forms  ////////////////////
176.create a new LoginForm.jsx file with a cc in the components folder:
import React, { Component } from "react";

class LoginForm extends Component {
  state = {};
  render() {
    return <h1>Login</h1>;
  }
}

export default LoginForm;
177.import Login then register a new login route in App.jsx:
import LoginForm from "./LoginForm";
...
<Route path="/login" component={LoginForm} />
178.add a link to login in the navigation bar:
<li className="nav-item">
  <NavLink className="nav-link" to="/login">
    Login
  </NavLink>
</li>
179.in LoginForm.jsx, enter the markup for the login form in the render():
class LoginForm extends Component {
  state = {};
  render() {
    return (
      <>
        <h1>Login</h1>
        <form>
          <div className="form-group">
            <label htmlFor="username">Username</label>
            <input id="username" type="text" className="form-control" />
          </div>
          <div className="form-group">
            <label htmlFor="password">Password</label>
            <input id="password" type="text" className="form-control" />
          </div>
          <button className="btn btn-primary">Login</button>
        </form>
      </>
    );
  }
}
180.prevent default form submit behavior (server round-trip) with a handleSubmit:
class LoginForm extends Component {
  handleSubmit = e => {
    e.preventDefault();
  };

  render() {
    return (
      <>
        <h1>Login</h1>
        <form onSubmit={this.handleSubmit}>
...
181.get access to the username <input/> DOM element with a ref:
class LoginForm extends Component {
  usernameInput = React.createRef();

  handleSubmit = e => {
    e.preventDefault();
    console.log("Logging in", this.usernameInput.current.value);
  };

  render() {
    return (
      <>
        <h1>Login</h1>
        <form onSubmit={this.handleSubmit}>
          <div className="form-group">
            <label htmlFor="username">Username</label>
            <input
              id="username"
              type="text"
              className="form-control"
              required
              ref={this.usernameInput}
            />
...
182.add a componentDidMount to acces and focus the username input:
componentDidMount() {
  this.usernameInput.current.focus();
}
183.or do it with autofcous ;)
184.create a new input.jsx file in the common folder:
import React from "react";

const Input = ({ name, label, value, onChange }) => {
  return (
    <div className="form-group">
      <label htmlFor={name}>{label}</label>
      <input
        autoFocus={name === "username" ? true : false}
        name={name}
        value={value}
        onChange={onChange}
        id={name}
        type={name === "password" ? "password" : "text"}
        className="form-control"
        required
      />
    </div>
  );
};

export default Input;
185.in LoginForm.jsx, import Input then replace the username and password 
inputs markup with the new <Input/> and add the corresponding needed props:
import Input from "./common/Input";
...
<form onSubmit={this.handleSubmit}>
  <Input
    name="username"
    value={account.username}
    label="Username"
    onChange={this.handleChange}
  />
  <Input
    name="password"
    value={account.password}
    label="Password"
    onChange={this.handleChange}
  />
  <button className="btn btn-primary">Login</button>
</form>
186.add an errors empty object to the LoginForm state:
state = {
  account: { username: "", password: "" },
  errors: {}
};
187.in the handleSubmit(), call a validate() that will update errors of state:
handleSubmit = e => {
  e.preventDefault();

  const errors = this.validate();
  this.setState({ errors });
  if (errors) return;

  console.log("Submitted");
};
188.create the validate method:
validate = () => {
  return { username: "Username is required." };
};
189.create basic validation by initializung an errors object in the validate =>:
const errors = {};
190.write validation logic for each input field:
if (account.username.trim() === "")
  errors.username = "Username is required.";

if (account.password.trim() === "")
  errors.password = "Password is required.";
191.finally, if any key was created in errors{}. return the errors object:
validate = () => {
  const errors = {};

  const { account } = this.state;
  if (account.username.trim() === "")
    errors.username = "Username is required.";

  if (account.password.trim() === "")
    errors.password = "Password is required.";

  return Object.keys(errors).length === 0 ? null : errors;
};
192.console.log errors just after calling this.validate() in the handleSubmit:
handleSubmit = e => {
  e.preventDefault();

  const errors = this.validate();
  console.log(errors);
  ...
193.in Input.jsx, just after the <input/>, add a div with the bootstrap 
classes alert and alert-danger:
<div className="alert alert-danger"></div>
194.get the error prop in the Input arguments:
const Input = ({ name, label, value, error, onChange }) => {
195.and render it in the new div:
<div className="alert alert-danger">{error}</div>
196.put the new div in an expression and prefix it with error && to
render the alert div only if there is something in error:
{error && <div className="alert alert-danger">{error}</div>}
197.in LoginForm.jsx, use object destructuring to get the errors object and set it
to the error prop of both <Input/> elements:
render() {
  const { account, errors } = this.state;
  return (
    <>
      <h1>Login</h1>
      <form onSubmit={this.handleSubmit}>
        <Input
          name="username"
          value={account.username}
          label="Username"
          onChange={this.handleChange}
          error={errors.username}
        />
        <Input
          name="password"
          value={account.password}
          label="Password"
          onChange={this.handleChange}
          error={errors.password}
        />
        <button className="btn btn-primary">Login</button>
      </form>
    </>
  );
}
198.in the hadleSubmit =>, set the state of errors to errors or empty object
(and get rid of unnecessary console.log):
handleSubmit = e => {
  e.preventDefault();

  const errors = this.validate();
  this.setState({ errors: errors || {} });
  if (errors) return;

  console.log("Submitted");
};
199.to validate on change, create a new errorMessage const in handleChange and assign it 
the return value of a new (to be defined) validateProperty:
const errorMessage = this.validateProperty(input);
200.clone erros of the state of <LoginForm/>:
const errors = { ...this.state.errors };
201.if the error message is truthy, store it in the corresponding input value of errors:
if (errorMessage) errors[input.name] = errorMessage;
202.otherwise, there is no error so delete the corresponding input value of tnis.state.errors:
else delete errors[input.name];
203.also pass the updated errors when calling setState:
this.setState({ account, errors });
204. the final handleChange:
handleChange = ({ currentTarget: input }) => {
  const errors = { ...this.state.errors };
  const errorMessage = this.validateProperty(input);

  if (errorMessage) errors[input.name] = errorMessage;
  else delete errors[input.name];
  //copy state
  const account = { ...this.state.account };
  //update username
  account[input.name] = input.value;
  //update state
  this.setState({ account, errors });
};
205.implement a temporary validateProperty:
validateProperty = ({ name, value }) => {
  //desrtuctured input.name and input.value
  if (name === "username") {
    if (value.trim() === "") return "Username is required";
    // ...
  }
  if (name === "password") {
    if (value.trim() === "") return "Password is required";
    // ...
  }
};
206.use joi third party library to validate:
https://www.npmjs.com/package/joi
207.npm install joi in the project:
npm i joi-browser
208.import joi in LoginForm.jsx:
import React, { Component } from "react";
import Joi from "joi-browser";
import Input from "./common/Input";
209.define a schema to use for joi:
schema = {
  username: Joi.string().required(),
  password: Joi.string().required()
};
210.in the validate =>, assign the result of the schema validation and console.log it:
const result = Joi.validate(this.state.account, this.schema);
console.log(result);
211.set abortEarly to false in the Joi validate result args:
const result = Joi.validate(this.state.account, this.schema, {
  abortEarly: false
});
console.log(result);
212.in the browser, click the login button to view the joi result in the console:
{error: Error: child "username" fails because ["username" is not allowed to be empty]. child "password" fail…, value: {…}, then: ƒ, catch: ƒ}catch: ƒ _catch(reject)error: Error: child "username" fails because ["username" is not allowed to be empty]. child "password" fails because ["password" is not allowed to be empty]
213.convert complex joi error description structure and convert it to a simplified version
that our app understands (map to state.errors {} where key is target field and value is message)
214.only keep the result definition in the validate =>:
validate = () => {
  //validate entire form

  const result = Joi.validate(this.state.account, this.schema, {
    abortEarly: false
  });
};
215.if error of result is falsy, return null:
if (!result.error) return null;
216.otherwise, take the result object and map it to our errors state object:
for (let item of result.error.details) {
  errors[item.path[0]] = item.message;
}
217.finally, return the errors object:
validate = () => {
  //validate entire form

  const result = Joi.validate(this.state.account, this.schema, {
    abortEarly: false
  });
  if (!result.error) return null;
  const errors = {};
  for (let item of result.error.details) {
    errors[item.path[0]] = item.message;
  }
  return errors;
};
218.test the app then correct the schema to get proper capitalization of the error strings:
schema = {
  username: Joi.string()
    .required()
    .label("Username"),
  password: Joi.string()
    .required()
    .label("Password")
};
219.improve the validate code with object destructuring:
validate = () => {
    //validate entire form

  const { error } = Joi.validate(this.state.account, this.schema, {
    abortEarly: false
  });
  if (!error) return null;
  const errors = {};
  for (let item of error.details) {
    errors[item.path[0]] = item.message;
  }
  return errors;
};
220.create a const for the 3rd arg:
validate = () => {
  //validate entire form
  const options = { abortEarly: false };
  const { error } = Joi.validate(this.state.account, this.schema, options);
  if (!error) return null;
  const errors = {};
  for (let item of error.details) {
    errors[item.path[0]] = item.message;
  }
  return errors;
};
221.delete the if statements in validateProperty than call Joi.validate with one input field
as the first argument (not entire form), a sub-schema (not entire form) as the second argument...
222.in validateProperty, create an object with a single property that should be dynamically set to
the passed name (using computed property name):
validateProperty = ({ name, value }) => {
  const obj = { [name]: value };
};
223.define a new const set to a new object containing the schema for the [name] obj only:
const schema = { [name]: this.schema[name] };
224.pick the error property and assign it the result of the Joi call:
const { error } = Joi.validate(obj, schema);
225.return the error message if there is one, or return null:
return error ? error.details[0].message : null;
226.test the app now that it can validate each input with this validateProperty:
validateProperty = ({ name, value }) => {
  const obj = { [name]: value };
  const schema = { [name]: this.schema[name] };
  const { error } = Joi.validate(obj, schema);
  return error ? error.details[0].message : null;
};
227.in LoginForm, set the disabled property of the button element to an immediate call to
this.validate; the call either returns null (falsy) or an object (truthy):
<button disabled={this.validate()} className="btn btn-primary">
  Login
</button>
228.in LoginForm.jsx, rename state account to data to begin extracting a reusable form
(find/replace all account with data)
229.in the common folder, create a new <Form/> component in which all reusable code 
can be copied (LoginForm will extend that new component instead of React's Component class)
230.initialize the state of Form with data and errors, both assigned to an empty object:
class Form extends Component {
  state = { 
    data: {},
    errors: {}
   }
   
  render() { 
    return (  );
  }
}
231.in LoginForm.jsx, leave the schema (login form specific) but cut the validate and
validateProperty code to paste it into Form (also import Joi, needed in validate
and get rid of render method in Form):
import React, { Component } from "react";
import { Joi } from "joi-browser";

class Form extends Component {
  state = {
    data: {},
    errors: {}
  };

  validate = () => {
    //validate entire form
    const options = { abortEarly: false };
    const { error } = Joi.validate(this.state.data, this.schema, options);
    if (!error) return null;
    const errors = {};
    for (let item of error.details) {
      errors[item.path[0]] = item.message;
    }
    return errors;
  };

  validateProperty = ({ name, value }) => {
    //validate each input
    //destructured input.name and input.value
    const obj = { [name]: value };
    const schema = { [name]: this.schema[name] };
    const { error } = Joi.validate(obj, schema);
    return error ? error.details[0].message : null;
  };
}

export default Form;
232.in LoginForm.jsx, refactor handleSubmit to exctract reusable e.preventDefault but
leave the rest (form specific onClick behavior):
handleSubmit = e => {
  //validate entire form
  e.preventDefault();

  const errors = this.validate();
  this.setState({ errors: errors || {} });
  if (errors) return;

  this.doSubmit();
};

doSubmit = () => {
  // Call the server
  console.log("Submitted");
};
233.now that handleSubmit is generic and reusable, cut and paste its code into Form.jsx,
just below validateProperty:
validateProperty = ({ name, value }) => {
  //validate each input
  //destructured input.name and input.value
  const obj = { [name]: value };
  const schema = { [name]: this.schema[name] };
  const { error } = Joi.validate(obj, schema);
  return error ? error.details[0].message : null;
};

handleSubmit = e => {
  //validate entire form
  e.preventDefault();

  const errors = this.validate();
  this.setState({ errors: errors || {} });
  if (errors) return;

  this.doSubmit();
};
234.cut the reusable code of handleChange in LoginForm to paste it in Form, below handleSubmit.
235.now that reusable code was split from specific code, make LoginForm class extend Form:
import React, { Component } from "react";
import Joi from "joi-browser";
import Input from "./common/Input";
import Form from "./common/Form";

class LoginForm extends Form {
  state = {
    data: { username: "", password: "" },
    errors: {}
  };
...
236.cut the <button/> markup from LoginForm and paste it into a new renderButton method
that takes a label parameter in Form:
renderButton = label => {
  return (
    <button disabled={this.validate()} className="btn btn-primary">
      {label}
    </button>
  );
};
237.back to LoginForm, call the new renderButton('Login'):
{this.renderButton("Login")}
238.the <Input/> components have repetitive code and need to be extracted like the
<button/>; cut the <Input/> markup from LoginForm and paste it into a new renderInput 
method that takes a label parameter in Form:
renderInput = (name, label) => {
  return (
    <Input
      name={name}
      value={data[name]}
      label={label}
      onChange={this.handleChange}
      error={errors[name]}
    />
  );
};
239.import the Input component in the Form and remove is import from LoginForm:
import Input from "./Input";
240.in LoginForm, call the new renderInput with the proper arguments for username and password:
<form onSubmit={this.handleSubmit}>
  {this.renderInput("username", "Username")}
  {this.renderInput("password", "Password")}
  {this.renderButton("Login")}
</form>
241.in LoginForm, cut the initialization code of data and errors and paste it in
Form.jsx where renderInput needs it:
renderInput = (name, label) => {
  const { data, errors } = this.state;
  return (
    <Input
      name={name}
      value={data[name]}
      label={label}
      onChange={this.handleChange}
      error={errors[name]}
    />
  );
};
242.add a type parameter with a default value of "text" to the renderInput():
renderInput = (name, label, type = "text") => {
243.in LoginForm, add the "password" value as the third argument of the renderInput() for password:
{this.renderInput("password", "Password", "password")}
244.in Input.jsx, add type as a picked property of Input and assign it to the type attribute:
const Input = ({ name, label, value, error, onChange, type }) => {
  return (
    <div className="form-group">
      <label htmlFor={name}>{label}</label>
      <input
        autoFocus={name === "username" ? true : false}
        name={name}
        value={value}
        onChange={onChange}
        id={name}
        type={type}
        className="form-control"
      />
      {error && <div className="alert alert-danger">{error}</div>}
    </div>
  );
};
245.group together all the <input/> attributes that have the same value as their name:
<input
  name={name}
  value={value}
  onChange={onChange}
  type={type}
  id={name}
  className="form-control"
  autoFocus={name === "username" ? true : false}
/>
246.pass these attributes with the ...rest operator:
const Input = ({ name, label, error, ...rest }) => {
247.automatically assign value, onChange and type with the spread operator:
<input
  {...rest}
  name={name}
  id={name}
  className="form-control"
  autoFocus={name === "username" ? true : false}
/>
248.the code below is equivalent to the code at 244:
const Input = ({ name, label, error, ...rest }) => {
  return (
    <div className="form-group">
      <label htmlFor={name}>{label}</label>
      <input
        {...rest}
        name={name}
        id={name}
        className="form-control"
        autoFocus={name === "username" ? true : false}
      />
      {error && <div className="alert alert-danger">{error}</div>}
    </div>
  );
};
