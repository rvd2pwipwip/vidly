1.in terminal, run create-react-app vidly
2.cd in vidly to install bootstrap and font-awesome:
npm i bootstrap@4.1.1 font-awesome@4.7.0
3.import css files for bootstrap and font-awesome in index.js:
import "bootstrap/dist/css/bootstrap.css";
import "font-awesome/css/font-awesome.css";
4.in the project folder, start the project:
npm start
5.replace the default react app with basic bootstrap template.
go to getbootstrap.com > examples > framework > starter template
look for <main role="main" class="container"> in page source
6.in App.js, delete everything in the return of the render() and replace with:
<main className="container">
  <h1>Hello World</h1>
</main>
7.get the Starter Code.zip and copy the Services folder in the project src folder
8.create components folder in src folder and create App.jsx component (will replace App.js)
9.create Movies component and test render with console log:
import React, { Component } from "react";
import { getMovies } from "../services/fakeMovieService";

class Movies extends Component {
  state = { movies: getMovies() };
  render() {
    return <h2>Movies Component</h2>;
  }
}

export default Movies;
10.import Movies in App.js and insert a <Movie/> component in the .main div:
import React, { Component } from "react";
import Movies from "./Movies";

class App extends Component {
  render() {
    return (
      <main className="container">
        <Movies />
      </main>
    );
  }
}

export default App;
11.create table in render method by typing table.table>thead>tr>th*4 to output (emmet):
render() {
    return (
      <table className="table">
        <thead>
          <tr>
            <th></th>
            <th></th>
            <th></th>
            <th></th>
          </tr>
        </thead>
      </table>
    );
  }
}
12.enter the 4 <th/> names:
<th>Title</th>
<th>Genre</th>
<th>Stock</th>
<th>Rate</th>
13.inside the <table/>, below the <thead>, create the body by typing tbody>tr>td*4
14.render the <td/> tags dynamically by applying a map function on the state.movies:
<tbody>
  {this.state.movies.map(m => (
    <tr key={m._id}>
      <td>{m.title}</td>
      <td>{m.genre.name}</td>
      <td>{m.numberInStock}</td>
      <td>{m.dailyRentalRate}</td>
    </tr>
  ))}
</tbody>
15.add a fifth <th/> with no text to the <thead/> and a fifth <td/> to the <tbody/> to add a delete button:
<td>
  <button className="btn btn-danger btn-sm"> //bootstrap styles for small red button
    Delete
  </button>
</td>
16.handle click event in <button/>:
<button
  className="btn btn-danger btn-sm"
  onClick={this.handleDelete}
>
  Delete
</button>
17.create new handleDelete => function just above render() in <Movies/>:
handleDelete = () => {
  console.log("deleting");
};
18.add the movie to be deleted as a parameter of handleDelete() and change the onClick call
of the <button/> to an => function so it can pass the movie id to handleDelete():
handleDelete = movie => {
  console.table(movie);
};

<button
  className="btn btn-danger btn-sm"
  onClick={() => {
    this.handleDelete(m);
  }}
>
  Delete
</button>
19.update the state by applying a filter to the current movies:
handleDelete = movie => {
  const movies = this.state.movies.filter(m => m._id !== movie._id);
  this.setState({ movies });
};
20.create a common folder inside the components folder
21.create a Like.jsx file inside the common folder
22.copy font awesome markup for empty heart icon and paste it into render() of <Like/>
don't forget to chege class to className -fontawesome was npm installed in the packages
(https://fontawesome.com/v4.7.0/icon/heart-o):
import React, { Component } from "react";

// input: liked boolean
// output: onClick

class Like extends Component {
  state = {};
  render() {
    return <i className="fa fa-heart-o" aria-hidden="true" />;
  }
}

export default Like;
22.in Movies.jsx, add a new column <th/> with a <Like/> inside before the delete <th>:
<table className="table">
  <thead>
    <tr>
      <th>Title</th>
      <th>Genre</th>
      <th>Stock</th>
      <th>Rate</th>
      <th />
      <th />
    </tr>
  </thead>
  <tbody>
    {this.state.movies.map(m => (
      <tr key={m._id}>
        <td>{m.title}</td>
        <td>{m.genre.name}</td>
        <td>{m.numberInStock}</td>
        <td>{m.dailyRentalRate}</td>
        <td>
          <Like />
        </td>
        <td>
          <button
            className="btn btn-danger btn-sm"
            onClick={() => {
              this.handleDelete(m);
            }}
          >
            Delete
          </button>
        </td>
      </tr>
    ))}
  </tbody>
</table>
23.create a liked prop inside the <Like/> component of the table and set it to true:
<Like liked={true} />
24.modify the <Like/> render() to change the className if liked props 
is true (className="fa fa-heart") or false (className="fa fa-heart-o"):
class Like extends Component {
  state = {};
  render() {
    let classes = "fa fa-heart";
    return (
      <i
        className={this.props.liked ? classes : `${classes}-o`}
        aria-hidden="true"
      />
    );
  }
}
25.in Movies.jsx, change the hard coded liked props to be dynamically set to each movie liked value:
<Like liked={m.liked} />
26.in fakeMovieService, add a liked property to the first movie and set it to true then save to confirm
27.set the onClick prop of <i/> in Like.jsx to props.handleLiked and add inline style for hand pointer:
return (
  <i
    className={this.props.liked ? classes : `${classes}-o`}
    aria-hidden="true"
    onClick={this.props.handleLiked}
    style={{ cursor: "pointer" }}
  />
);
28.in Movies.jsx, create the handleLiked prop inside the <Like/> component, set it to this.handleLiked()
and create the function handleLiked() to display a console.log('Liked'):
handleLiked = () => {
  console.log("Liked");
}
...
<Like liked={m.liked} handleLiked={this.handleLiked} />
29.change the handleLiked prop to an => function to pass the clicke movie to this.handleLiked:
<Like liked={m.liked} handleLiked={() => this.handleLiked(m)} />
30.change the handleLiked() to log which movie was clicked:
handleLiked = movie => {
  console.log("Liked", movie);
};
31.change the handleLiked() to copy the state, find the liked movie, toggle its liked property and updtae the state:
handleLiked = movie => {
  // 1. copy state
  const movies = [...this.state.movies];
  // 2. find movie index and update its liked property
  const index = movies.indexOf(movie);
  movies[index].liked = !movies[index].liked;
  // 3. update state
  this.setState({ movies });
};
32.Like.jsx can be changed to an sfc:
import React from "react";

const Like = props => {
  let classes = "fa fa-heart";
  return (
    <i
      className={props.liked ? classes : `${classes}-o`}
      aria-hidden="true"
      onClick={props.handleLiked}
      style={{ cursor: "pointer" }}
    />
  );
};

export default Like;
33.create a new Pagination.jsx file inside common, then imr and sfc, 
name the component Pagination and pass the props as an argument:
import React from "react";

const Pagination = props => {
  return ();
};

export default Pagination;
34.go to bootstrap documentation and find the markup for a pagination component
(https://getbootstrap.com/docs/4.1/components/pagination/) to paste it in the return():
import React from "react";

const Pagination = props => {
  return (
    <nav aria-label="Page navigation example">
      <ul className="pagination">
        <li className="page-item">
          <a className="page-link" href="#">
            1
          </a>
        </li>
      </ul>
    </nav>
  );
};

export default Pagination;
35.in Movies.jsx, import then add the new <Pagination/> component below the table:
import Pagination from "./common/Pagination";
...
<Pagination/>
36.add pagination props to the component (# of items and page size):
<Pagination itemsCount={this.state.movies.length} pageSize={this.state.pageSize} />
37.initialize pageSize property in the state:
state = { movies: getMovies(), pageSize: 4 };
38.add handlePageChange prop to Pagination:
<Pagination
  itemsCount={this.state.movies.length}
  pageSize={this.state.pageSize}
  handlePageChange={this.handlePageChange}
/>
39.create the handlePageChange function of Movies to confirm with a log:
handlePageChange = page => {
  console.log(page);
};
40.in Pagination.jsx, create the itemsCount and PageSize const to determine the page count:
const { itemsCount, pageSize } = props;
const pagesCount = Math.ceil(itemsCount / pageSize);
41.console cd in vidly and npm install lodash to use it to generate an array of the number of pages:
npm i lodash@4.17.10
42.import lodash in Pagination.jsx:
import _ from "lodash";
43.use lodash to create a pages array with keys [1, 2, 3]:
const pages = _.range(1, pagesCount + 1);
44.map the pages array to create a <li/> for each page:
<ul className="pagination">
  {pages.map(p => (
    <li key={p} className="page-item">
      <a className="page-link" href="#">
        {p}
      </a>
    </li>
  ))}
</ul>
45.in Pagination.jsx raise the click event of the <a/> element:
<a className="page-link" onClick={() => props.handlePageChange(p)}>{p}</a>
46.keep using already created object destructuring for props.handlePageChange:
const { itemsCount, pageSize, handlePageChange } = props;
...
<a className="page-link" onClick={() => handlePageChange(p)}>
47.to highlight the current page on the <Pagination/> component, create a currentPage
porperty in Movies.sate and pass it down to <Pagination/> then to <a/> via props:
state = { movies: getMovies(), pageSize: 4, currentPage: 1 };
...
<Pagination
  itemsCount={this.state.movies.length}
  pageSize={this.state.pageSize}
  handlePageChange={this.handlePageChange}
  currentPage={this.state.currentPage}
/>
... in Pagination.jsx:
const { itemsCount, pageSize, handlePageChange, currentPage } = props;
48.refactor Movies.jsx state properties with object destructuring:
render() {
  const { length: count } = this.state.movies;
  const { pageSize, currentPage } = this.state;
...
<p>Showing {count} movies in the database.</p>
...
<Pagination
  itemsCount={count}
  pageSize={pageSize}
  currentPage={currentPage}
  handlePageChange={this.handlePageChange}
/>
49.change code of handlePageChange() to update the state of Movies:
handlePageChange = page => {
  this.setState({ currentPage: page });
};
50.use ternary expression to append 'active' to the class of <li/> if it is the current page:
<li
  key={p}
  className={currentPage === p ? "page-item active" : "page-item"}
>
  <a className="page-link" onClick={() => handlePageChange(p)}>
    {p}
  </a>
</li>
51.create a new utils folder inside src and add a new paginate.js file inside.
52.import lodash in the paginate.js file:
import _ from "lodash";
53.export the paginate function that will be written in this file:
export function paginate()
54.add the parameters that will be neede to paginate:
export function paginate(items, pageNumber, pageSize)
55.calculate the starting index of items on current page:
const startIndex = (pageNumber - 1) * pageSize;
56.chain lodash methods to return new array of page items:
return _(items)
  .slice(startIndex)
  .take(pageSize)
  .value();
57.import the paginate function in Movies.jsx:
import { paginate } from "../utils/paginate";
58.inside render(), call the paginate() and pass the state movies, currentPage and PageSize:
const { pageSize, currentPage, movies } = this.state;
...
const movies = paginate(movies, currentPage, pageSize);
59.instead of mapping this.state.movies, we need to map over the local (paged) movies:
<tbody>
  {movies.map(m => (
60.remove duplicate declaration "movies" error by renaming movies in destructured declaration:
const { pageSize, currentPage, movies: allMovies } = this.state;
...
const movies = paginate(allMovies, currentPage, pageSize);
61.console cd in vidly and npm install prop-types in the project to allow type checking:
npm i prop-types@15.6.2
62.import prop-types in the Pagination component:
import PropTypes from 'prop-types'
63.add new propTypes property to Pagination below its definition:
...
};

Pagination.propTypes = {
  itemsCount: PropTypes.number.isRequired,
  pageSize: PropTypes.number.isRequired,
  handlePageChange: PropTypes.func.isRequired,
  currentPage: PropTypes.number.isRequired
};

export default Pagination;
64.create a new FilterGroup.jsx file inside the common folder
65.in FilterGroup.jsx, imr and sfc to write code for a stateless functional component named FilterGroup:
import React from "react";

const FilterGroup = props => {
  return (  );
};

export default FilterGroup;
66.in Movies.jsx, import the new FilterGroup component:
import FilterGroup from "./common/FilterGroup";
67.replace the React.Fragment <></> with a div with a className of row that has two col divs inside
div.row>div.col-3+div.col:
<div className="row">
  <div className="col-3"></div>
  <div className="col"></div>
</div>
68.put a <FilterGroup/> inside the first col and put all the rest in the second col:
<div className="row">
  <div className="col-3">
    <FilterGroup/>
  </div>
  <div className="col">
    <p>Showing {count} movies in the database.</p>
    <table className="table">
    ...
69.import the genres list with getGenres() from fakeGenreService.js into Movies.jsx:
import { getGenres } from "../services/fakeGenreService";
70.add the genres property in the state and assign it an empty array:
state = {
  movies: getMovies(),
  genres: [],
  pageSize: 4,
  currentPage: 1,
  currentFilter: null
};
71.add a componentDidMount() below the state:
componentDidMount(){
  
}
72.assign an empty array to the movies of state:
state = {
  movies: [],
  genres: [],
  pageSize: 4,
  currentPage: 1,
  currentFilter: null
};
73.set the state movies and genres in the componentDidMount():
componentDidMount() {
  this.setState({ movies: getMovies(), genres: getGenres() });
}
74.pass the genres of state as an items prop of FilterGroup:
<FilterGroup items={this.state.genres} />
75.add an item selection event handler to FilterGroup:
<FilterGroup
  items={this.state.genres}
  handleItemSelect={this.handleGenreSelect}
/>
76.add a handleGenreSelect() to Movies that will console log the passed genre:
handleGenreSelect = genre => {
  console.log(genre);
}
77.in FilterGroup.js, destructure the passed items props and map each of them to a <li/> elements
of the list-group ul (https://getbootstrap.com/docs/4.1/components/list-group/):
const FilterGroup = props => {
  const { items } = props;

  return (
    <ul className="list-group">
      {items.map(i => (
        <li key={i._id} className={"list-group-item"}>
          {i.name}
        </li>
      ))}
    </ul>
  );
};
78.to decouple the FilterGroup component from the data of Movies, add 2 new props to 
<FilterGroup/> in Movies.jsx:
<FilterGroup
  items={this.state.genres}
  textProperty="name"
  valueProperty="_id"
  handleItemSelect={this.handleGenreSelect}
/>
79.grab the 2 new props inside FilterGroup.jsx:
const { items, textProperty, valueProperty } = props;
80.replace . notation with [] notation to get the .name and the ._id of each <li/>:
<ul className="list-group">
  {items.map(i => (
    <li key={i[valueProperty]} className={"list-group-item"}>
      {i[textProperty]}
    </li>
  ))}
</ul>
81.in FilterGroup.jsx, use defaultProps to simplify the <FilterGroup/> in Movies.jsx 
(no need to pass the defaultProps):
FilterGroup.defaultProps = {
  valueProperty: "_id",
  textProperty: "name"
};
82.in FilterGroup.jsx, deconstruct the handleItemSelect fucntion passed via props:
const { items, textProperty, valueProperty, handleItemSelect } = props;
83.add an onClick event to the <li/> elements of FilterGroup to call handleItemSelect and pass
the clicked item (and add the style={{ cursor: "pointer" }} attribute):
<li
  key={i[valueProperty]}
  className={"list-group-item"}
  onClick={() => handleItemSelect(i)}
  style={{ cursor: "pointer" }}
>
  {i[textProperty]}
</li>
84.in FilterGroup.jsx, write the handleGenreSelect to set the state to the clicked item:
handleGenreSelect = genre => {
  this.setState({ selectedGenre: genre });
};
85.in FilterGroup.jsx, extract the new prop (selectedItem):
const { items, textProperty, valueProperty, handleItemSelect, selectedItem } = props;
86.dynamically change the class of <li/> if its item is the same as the one that was clicked:
<li
  key={i[valueProperty]}
  className={
    i === selectedItem ? "list-group-item active" : "list-group-item"
  }
  onClick={() => handleItemSelect(i)}
  style={{ cursor: "pointer" }}
>
  {i[textProperty]}
</li>
87.in Movies.jsx render method, extract the selectedGenre from the state 
(along with other deconstructed state properties):
88.filter the movies before pagination with ternary operator:
const filteredMovies = selectedGenre
  ? allMovies.filter(m => m.genre._id === selectedGenre._id)
  : allMovies;
89.paginate filteredMovies instead of allMovies:
const movies = paginate(filteredMovies, currentPage, pageSize);
90.in the <Pagination/> component, assign the filteredMovies.length to itemsCount (instead of count):
<Pagination
  itemsCount={filteredMovies.length}
  pageSize={pageSize}
  currentPage={currentPage}
  handlePageChange={this.handlePageChange}
/>
91.in the <p/>, change the { count } to { filteredMovies.length } to show the proper number of
movies shown:
<p>Showing {filteredMovies.length} movies in the database.</p>
92.add All Genres in state genres array and set the state with this new array:
componentDidMount() {
  const genres = [{ _id: 0, name: "AllGenres" }, ...getGenres()];
  this.setState({ movies: getMovies(), genres });
}
93.change the filter condition so it doesn't filter if the id of selectedGenre is 0
const filteredMovies =
  selectedGenre && selectedGenre !== 0
    ? allMovies.filter(m => m.genre._id === selectedGenre._id)
    : allMovies;
94.reset the current page to page 1 whenever a genre is selected:
handleGenreSelect = genre => {
  this.setState({ selectedGenre: genre, currentPage: 1 });
};
95.refactor the table into its own sfc file:
import React from "react";
import Like from "./common/Like";

const MoviesTable = props => {
  const { movies, handleDelete, handleLiked } = props;
  return (
    <>
      <table className="table">
        <thead>
          <tr>
            <th>Title</th>
            <th>Genre</th>
            <th>Stock</th>
            <th>Rate</th>
            <th />
            <th />
          </tr>
        </thead>
        <tbody>
          {movies.map(m => (
            <tr key={m._id}>
              <td>{m.title}</td>
              <td>{m.genre.name}</td>
              <td>{m.numberInStock}</td>
              <td>{m.dailyRentalRate}</td>
              <td>
                <Like liked={m.liked} handleLiked={() => handleLiked(m)} />
              </td>
              <td>
                <button
                  className="btn btn-danger btn-sm"
                  onClick={() => {
                    handleDelete(m);
                  }}
                >
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </>
  );
};

export default MoviesTable;
96.import the MoviesTable component in Movies.jsx:
import MoviesTable from "./MoviesTable";
97.insert the <MoviesTable/> between <p/> and <Pagination/> with the needed props:
<MoviesTable
  movies={movies}
  handleDelete={this.handleDelete}
  handleLiked={this.handleLiked}
/>
98.in MoviesTable.jsx, extract a new handleSort with props destructuring:
const { movies, handleDelete, handleLiked, handleSort } = props;
99.assign the handleSort prop to the onClick of each <th/> and pass the appropriate sort criteria:
<tr>
  <th onClick={() => handleSort("title")}>Title</th>
  <th onClick={() => handleSort("genre.name")}>Genre</th>
  <th onClick={() => handleSort("numberInStock")}>Stock</th>
  <th onClick={() => handleSort("dailyRentalRate")}>Rate</th>
  <th />
  <th />
</tr>
100.in Movies.jsx, assign the handleSort as a props of <MoviesTable/>:
<MoviesTable
  movies={movies}
  handleDelete={this.handleDelete}
  handleLiked={this.handleLiked}
  handleSort={this.handleSort}
/>
101.create the handleSort() and console.log the passed argument to validate the plumbing works:
handleSort = sort => {
  console.log("sorting", sort);
};
102.modify the handleSort() to set the state by passing a sortColumn object:
handleSort = sort => {
  this.setState({ sortColumn: { sort: sort, order: "asc" } });
};
103.add a new sortColumn property to the state of Movies.jsx:
state = {
  movies: [],
  genres: [],
  pageSize: 4,
  currentPage: 1,
  sortColumn: { sort: "title", order: "asc" }
};
104.import lodash into Movies.jsx to use it to implement the ascending sort:
import _ from "lodash";
105.extract the sortColumn from the state object destructuring inside the render():
const {
  pageSize,
  currentPage,
  movies: allMovies,
  selectedGenre,
  sortColumn
} = this.state;
105.in the render method, sorting should be done between filtering and paginating:
const sorted = _.orderBy(
  filteredMovies,
  [sortColumn.sort],
  [sortColumn.order]
);
106.pass the sorted movies to paginate:
const movies = paginate(sorted, currentPage, pageSize);
107.implement the reverse sort:
handleSort = sort => {
  const sortColumn = { ...this.state.sortColumn };
  if (sortColumn.sort === sort) {
    sortColumn.order = sortColumn.order === "asc" ? "desc" : "asc";
  } else {
    sortColumn.sort = sort;
    sortColumn.order = "asc";
  }
  this.setState({ sortColumn });
};
107.to move the sorting code from Movies to MoviesTable, promote MoviesTable from sfc to cc:
import React, { Component } from "react";
import Like from "./common/Like";

class MoviesTable extends Component {
  state = {};

  render() {
    const { movies, handleDelete, handleLiked, handleSort } = this.props;
    return (
      <>
        <table className="table">
          <thead>
            <tr>
              <th onClick={() => handleSort("title")}>Title</th>
              <th onClick={() => handleSort("genre.name")}>Genre</th>
              <th onClick={() => handleSort("numberInStock")}>Stock</th>
              <th onClick={() => handleSort("dailyRentalRate")}>Rate</th>
              <th />
              <th />
            </tr>
          </thead>
          <tbody>
            {movies.map(m => (
              <tr key={m._id}>
                <td>{m.title}</td>
                <td>{m.genre.name}</td>
                <td>{m.numberInStock}</td>
                <td>{m.dailyRentalRate}</td>
                <td>
                  <Like liked={m.liked} handleLiked={() => handleLiked(m)} />
                </td>
                <td>
                  <button
                    className="btn btn-danger btn-sm"
                    onClick={() => {
                      handleDelete(m);
                    }}
                  >
                    Delete
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </>
    );
  }
}

export default MoviesTable;
108.copy the code from the handleSort() of Movies.jsx in a new onSort() in MoviesTable.jsx
and modify it to get the sortColumn from the props (instead of state) and return the updated
sortColumn to the handleSort() of Movies.jsx:
onSort = sort => {
  const sortColumn = { ...this.props.sortColumn };
  if (sortColumn.sort === sort) {
    sortColumn.order = sortColumn.order === "asc" ? "desc" : "asc";
  } else {
    sortColumn.sort = sort;
    sortColumn.order = "asc";
  }
  this.props.handleSort(sortColumn);
};
109.in Movies.jsx, pass the sortColumn of state and the handleSort() as props of MoviesTable:
<MoviesTable
  movies={movies}
  handleDelete={this.handleDelete}
  handleLiked={this.handleLiked}
  sortColumn={this.state.sortColumn}
  handleSort={this.handleSort}
/>
110.update the handleSort() to receive the sortColumn argument (instead of sort):
handleSort = sortColumn => {
  this.setState({ sortColumn });
};
111.create a new tableHeader.jsx cc file in the common folder:
import React, { Component } from 'react';

class TableHeader extends Component {
  state = {  }
  render() { 
    return (  );
  }
}
 
export default TableHeader;
112.copy the sorting code from MoviesTable into TableHeader:
class TableHeader extends Component {
  state = {  }

  onSort = sort => {
    const sortColumn = { ...this.props.sortColumn };
    if (sortColumn.sort === sort) {
      sortColumn.order = sortColumn.order === "asc" ? "desc" : "asc";
    } else {
      sortColumn.sort = sort;
      sortColumn.order = "asc";
    }
    this.props.handleSort(sortColumn);
  };

  render() { 
    return (  );
  }
}
113.add render code to display a <thead> with a <tr> that has a <th> for each column:
render() { 
  return ( 
    <thead>
      <tr>
        {this.props.columns.map(c => <th>{c.label}</th>)}
      </tr>
  </thead> );
} 
114.copy the first <th> onClick expression from MoviesTable in the <th> of TableHeader:
<thead>
  <tr>
    {this.props.columns.map(c => (
      <th onClick={() => this.onSort("title")}>{c.label}</th>
    ))}
  </tr>
</thead>
115.instead of "title", pass the path to the target property:
<th onClick={() => this.onSort(c.path)}>{c.label}</th>
116.import the new <TableHeader/> in MoviesTable.jsx:
import TableHeader from "./common/TableHeader";
...
117.create a new columns array in MoviesTable:
class MoviesTable extends Component {
  columns = [
    { path: "title", label: "Title" },
    { path: "genre.name", label: "Genre" },
    { path: "numberInStock", label: "Stock" },
    { path: "dailyRentalRate", label: "Rate" },
    {}, //like col, no path no label
    {} //delete col, no path no label
  ]; //will not change, no need for a state
118.replace the <thead/> by the new <TableHeader/> with the needed props:
render() {
  const {
    movies,
    handleDelete,
    handleLiked,
    handleSort,
    sortColumn
  } = this.props;
  return (
    <>
      <table className="table">
        <TableHeader
          columns={this.columns}
          sortColumn={sortColumn}
          handleSort={handleSort}
        />
        <tbody>
        ...
119.add key attributes to the like and delete columns of MoviesTable:
columns = [
  { path: "title", label: "Title" },
  { path: "genre.name", label: "Genre" },
  { path: "numberInStock", label: "Stock" },
  { path: "dailyRentalRate", label: "Rate" },
  { key: "like" }, //like col, no path no label
  { key: "delete" } //delete col, no path no label
]; //will not change, no need for a state
120.in TableHeader.jsx, add a key attribute to the <th/> assigned to either
the column path or the column key (for like and delete):
<tr>
  {this.props.columns.map(c => (
    <th key={c.path || c.key} onClick={() => this.onSort(c.path)}>
      {c.label}
    </th>
  ))}
</tr>
121.create a new TableBody.jsx cc file in the common folder:
import React, { Component } from 'react';

class TableBody extends Component {
  state = {  }
  render() { 
    return (  );
  }
}
 
export default TableBody;
122.in MoviesTable.jsx, import the new TableBody and insert it below the <TableHeader/>:
import TableBody from "./common/TableBody";
...
<TableHeader
  columns={this.columns}
  sortColumn={sortColumn}
  handleSort={handleSort}
/>
<TableBody/>
...
124.add a data attribute to <TableBody/> to pass the (decoupled) movies:
<TableBody data={movies} />
125.the <TableBody/> should return <tbody> elements:
render() {
    return (
      <tbody>
        <tr>
          <td />
        </tr>
      </tbody>
    );
  }
126.use object destructuring to extract the props data (movies) and the columns:
render() {
  const { data, columns } = this.props;
  return (
    <tbody>
      {data.map(i => (
        <tr>
          {columns.map(c => (
            <td />
          ))}
        </tr>
      ))}
    </tbody>
  );
}
127.import lodash to use the _.get() that can get nested properties (like genre.name):
<tbody>
  {data.map(i => (
    <tr>
      {columns.map(c => (
        <td>{_.get(i, c.path)}</td>
      ))}
    </tr>
  ))}
</tbody>
128.in the columns array of MoviesTable, pass the jsx markup for the like and the
delete columns as content attributes:
columns = [
  { path: "title", label: "Title" },
  { path: "genre.name", label: "Genre" },
  { path: "numberInStock", label: "Stock" },
  { path: "dailyRentalRate", label: "Rate" },
  {
    key: "like",
    content: <Like liked={m.liked} handleLiked={() => handleLiked(m)} />
  },
  {
    key: "delete",
    content: (
      <button
        className="btn btn-danger btn-sm"
        onClick={() => {
          handleDelete(m);
        }}
      >
        Delete
      </button>
    )
  }
];
129.get rid of the old <tbody/> markup in MoviesTable.jsx:
<table className="table">
  <TableHeader
    columns={this.columns}
    sortColumn={sortColumn}
    handleSort={handleSort}
  />
  <TableBody data={movies} columns={this.columns} />
</table>
130.in the columns array, change the content attribute of like and delete from react
elements to arrow functions and pass the handleLiked() and handleDelete() from this.props:
{
  key: "like",
  content: m => (
    <Like liked={m.liked} handleLiked={() => this.props.handleLiked(m)} />
  )
},
{
  key: "delete",
  content: m => (
    <button
      className="btn btn-danger btn-sm"
      onClick={() => {
        this.props.handleDelete(m);
      }}
    >
      Delete
    </button>
  )
}
131.create a new renderCell() to render <td/> with a content attribute or path:
class TableBody extends Component {
  renderCell = (i, c) => {
    if (c.content) return c.content(i);
    return _.get(i, c.path);
  };
132.call the renderCell in the <tr/>:
<tr>
  {columns.map(c => (
    <td>{this.renderCell(i, c)}</td>
  ))}
</tr>
133.in TableBody.jsx, give unique keys to the <tr/> and <td/> elements based on
the id of their data:
{data.map(i => (
  <tr key={i._id}>
    {columns.map(c => (
      <td key={i._id + (c.path || c.key)}>{this.renderCell(i, c)}</td>
    ))}
  </tr>
))}
134.simplify the <td/> code by creating a createKey():
createKey = (i, c) => {
  return i._id + (c.path || c.key);
};

render() {
  const { data, columns } = this.props;
  return (
    <tbody>
      {data.map(i => (
        <tr key={i._id}>
          {columns.map(c => (
            <td key={this.createKey(i, c)}>{this.renderCell(i, c)}</td>
          ))}
        </tr>
      ))}
    </tbody>
  );
}
135.handleDelete and handleLike are not needed in MoviesTable.jsx anymore:
render() {
  const {
    movies,
    // handleDelete,
    // handleLiked,
    handleSort,
    sortColumn
  } = this.props;